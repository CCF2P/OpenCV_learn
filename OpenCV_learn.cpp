#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>   // содержит функции для отображения изображений в графическом окне
#include <opencv2/objdetect.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>

// using namespace std; // пространство имен std (чтобы не писать std::...)
// using namespace cv; // пространство имен cv (чтобы не писать cv::...)

/*
* example1 - процедура, которая содержит простой пример для работы
* с изображениями. Она показывает как открыть изображение и вывести его
* на экран.
*/
void example1()
{
	// переменная path содержить путь к файлу-картинке
	std::string path = "E:/OpenCV_learn/Resources/Images/Test.png";

	/*
	cv::Mat - класс для хранения изображений в openCV с двумя частями данных:
	1 - заголовком матрицы (содержащим такую ​​информацию, как размер матрицы,
		метод, используемый для хранения, адрес, по которому хранится матрица, и т. д.)
	2 - указателем на матрицу, содержащую значения каждого пикселя изображения
		(под значением пикселя понимается три числа BGR (blue, green, red), которые и задают цвет пикселя).

	Причем важно помнить, что в openCV значение пикселя - BGR, а в других библиотеках - RGB (red,
	green, blue).
	*/
	cv::Mat img, img1;
	
	/*
	imread() - функция, для считывания изображения из файла.

	Параметры:
	1 - string filename - путь к файлу, в котором хранится изображение. Поддерживает следующие форматы
		изображений: png, jpeg, jpg, gif и т.д. НО!!! Есть особенности, которые зависят от ОС и версии openCV.
	2 - int flags - флаги (специальные значения) для определения каким образом
		будет считываться изображение, например:
		IMREAD_UNCHANGED - возвращает изображение таким какое оно есть (с альфа каналом).
		IMREAD_GRAYSCALE - всегда конвертирует изображение в одноканальное серое изображение.
		IMREAD_COLOR_BGR - всегда конвертирует изображение в 3-х канальное BGR цветное изображение.
		IMREAD_ANYCOLOR - считывает изображение в том формате, в котором может.
		IMREAD_COLOR_RGB - всегда конверитует изображение в 3-х канальное RGB цветное изображение.
	И другие... (смотри сайт с документацией)
	*/
	img = cv::imread(path); // Без флага
	img1 = cv::imread(path, cv::IMREAD_GRAYSCALE); // С флагом

	/*
	imshow() - функция, которая создает графическое окно с такой же шириной и высотой,
	как у изображение, которое передается в функцию.
	 
	Параметры:
	1 - string winname - графического окна, если необходимо создать несколько окон, то
		необходимо их по разному называть, т.к. окна с одним и тем же названием считаются
		как одно.
	2 - InputArray mat - изображение, которе необходимо нарисовать в графическом окне.
	*/
	cv::imshow("Image", img);

	/*
	cv::waitKey() - функция для задержки графического окна. Если ее убрать, то
	результат не будет задерживаться на экране компьютера.

	0 - программа ждет нажатия клавиш или закрытия окна.
	число > 0 - время в миллисекундах, через сколько закроется окно.
	*/
	cv::waitKey(0);
}

/*
example2 - процедура, которая содержит пример для изменения изображения.
*/
void example2()
{
	std::string path = "E:/OpenCV_learn/Resources/Images/Test.png";
	cv::Mat img = cv::imread(path);

	// Переменные для хранения измененных изображений
	cv::Mat imgGray, imgBlur, imgGaussian, imgThresh;

	/*
	cvtColor() - функция, которая конвертирует изображение из одного
	цветого пространства в другое (например цветное сделать черно-белым).

	Параметры:
	1 - InputArray src - изображение, которые необходимо конвертировать
	2 - OutputArray dst - изображение, которые будет в себе хранить уже измененное
		исходное изображение.
	3 - int code - число, которе определяет в какое цветовое пространство конвертировать,
		например:
		COLOR_BGR2BGRA - перевести изображение из BGR в BGRA, т.е. добавать альфа канал.
		COLOR_RGB2RGBA - аналогично COLOR_BGR2BGRA, только для RGB.
		COLOR_BGRA2BGR - перевести изображение из BGRA в BGR, т.е. удалить альфа канал.
		COLOR_RGBA2RGB - аналогично COLOR_BGRA2BGR, только для RGB.
		COLOR_RGB2GRAY - перевести изображение из RGB в GRAY, т.е. перекрасить изображение оттенками серого.
		COLOR_BGR2GRAY - аналогично COLOR_RGB2GRAY, только для BGR.
	И другие... (смотри сайт с документацией)
	*/
	cv::cvtColor(img, imgGray, cv::COLOR_BGR2GRAY);

	/*
	Функции для размытия (сглаживания) изображения:

	1 - blur() - усредненное размытие.
	Параметры:
	1. InputArray src - изображение, которе необходимо размыть
	2. OutputArray dst - изображение, которе будет хранить результат размытия
	3. Size ksize - размер ядра по которому будет считаться усреденение
	4. Point anchor - точка привязки ядра, по умолчанию равна (-1, -1) это значит, что
	   точка находится в середине ядра. Т.к. ядро это матрица, то можно указать какой-нибудь
	   элемент матрицы в который будет записывать высчитанное размытие. Если указать (0, 0) или (3, 3)
	   (при условии, что ядро 4х4), то в результате размытие будет смещено в левый верхний или правый нижний угол.
	5. int borderType - режим границы, используемый для экстраполяции пикселей за пределами изображения.
	   (Смотри документацию - BorderTypes)

	2 - GaussianBlur() - взвешенное среднее размытие.
	Параметры:
	1. InputArray src - изображение, которе необходимо размыть
	2. OutputArray dst - изображение, которе будет хранить результат размытия
	3. Size ksize - размер ядра по которому будет считаться взвешенное усреденение. Размер ядро
	   должен состоят из нечетных чисел!!!
	4. int sigmaX, simgaY - отклонение гауссового ядра по оси X и Y. Если sigmaY равно нулю,
	   оно устанавливается равным sigmaX, если оба sigma равны нулю, они вычисляются и
	   ksize.width и ksize.height соответственно
	5. AlgorithmHint hint - флаг для изменения поведения реализации функции. (см. AlgorithmHint)

	3 - И другие... (смотри сайт с документацией)
	*/
	cv::blur(img, imgBlur, cv::Size(4, 4), cv::Point(3, 3));
	cv::GaussianBlur(imgGray, imgGaussian, cv::Size(7, 7), 5, 0);

	/*
	threshold() - функция для приведения изображения к двум цветам - черному и белому.
	Для этого лучше всего заранее перевести изображение к оттенкам серого (grayscale).

	Параметры:
	1. InputArray src - изображение, которе необходимо размыть
	2. OutputArray dst - изображение, которе будет хранить результат функции
	3. double thresh - пороговое значение. Если значение пикселя меньше порогового значения, то
	   пикселю присваивается 0, иначе 1.
	4. double maxval - определяет значение, которое присваивается пикселям, удовлетворяющим условию порога.
	5. int type - тип порога (см. ThresholdTypes)
	*/
	cv::threshold(imgBlur, imgThresh, 100, 200, cv::THRESH_BINARY);


	cv::imshow("Grayscale", imgGray);
	cv::imshow("Blur", imgBlur);
	cv::imshow("GaussianBlur", imgGaussian);
	cv::waitKey(0);
}

/*
example3() - процецдура, которая содержит пример для рисования 2D
геометрических фигур на картинка/видео
*/
void example3()
{
	/*
	Изображение можно создать, а не только загрузить из файла.
	Для этого в конструкторе cv::Mat можно задать количество строк (rows),
	стобцов (cols) и тип изображения. Тип изображения составляется по следующей структуре:

	CV_<кол-во бит на цвет><тип данных>C<кол-во цветов>

	<кол-во бит на цвет> - может принимать значения 8, 16, 32, 64. В случае 64-х цветов <тип данных> всегда F.
	<тип данных> - U - unsigned integer
	               S - signed integer
				   F - float
	<кол-во цветов> - целое число от 1 до 4. Если выбрать 3, то будет BGR

	Небольшие пояснения:
	1 - кол-во цветов которые может принимать пиксель = 2^(<кол-во бит на цвет>), например
		<кол-во бит на цвет> = 8 и <тип данных> = U, тогда пиксель принимает значения от 0 до 255 (всего 256).
		Если <кол-во бит на цвет> = 8 и <тип данных> = S, тогда пиксель принимает значения от -128 до 127 (всего 256) и т.д.
		Еще примеры:
		<кол-во бит на цвет> = 16 и <тип данных> = U -> от 0 до 65535
		<кол-во бит на цвет> = 16 и <тип данных> = S -> от -32768 до 32767
		<кол-во бит на цвет> = 32 и <тип данных> = U -> от 0 до 4294967295
		<кол-во бит на цвет> = 32 и <тип данных> = S -> от -2147483648 до 2147483647
	2 - Глубина цвета зависит от формата изображения (PNG, JPEG, и т.п.). В машинном зрение чаще всего используется
		8 бит (или вообще два цвета черный и белый).
	*/
	cv::Mat img(256, 256, CV_8UC3); // Пример создания изображения.
									// Размер = 256х256
	                                // Типа изображения = CV_8UC3

	/*
	circle() - функция для отрисовки окружности в кадре.

	Параметры:
	1 - InputOutputArray img - изображение на котором будет отображаться окружность.
	2 - Point center - центр окружность
	3 - int radius - радиус окружности
	4 - Scalar color - цвет окржности. Задается тремя числами BGR, от 0 до 255.
	5 - int thickness - толщина линии окружности
	6 - int lineType - тип линии. Задается числом или названием, например:
		cv::FILLED = -1
		cv::LINE_4 = 4
		cv::LINE_8 = 8
		cv::LINE_AA = 16
	7 - int shift - указывает, на сколько бит сдвинуть дробные части координат (x, y) и радиуса radius.
		Т.е. реальные координаты окружности = (переданные значения)/2^(shift).
		При shift = 0, координаты являются целыми числами.

	rectangle() - функция для отрисовки прямоугольника в кадре.

	Параметры:
	1 - InputOutputArray img - изображение на котором будет отображаться окружность.
	2 - Rect rect - прямоугольник, которые задается координатами левого верхнего угла, а также
		шириной и высотой.
	4 - Scalar color - цвет окржности. Задается тремя числами BGR, от 0 до 255.
	5 - int thickness - толщина линии окружности
	6 - int lineType - тип линии. Задается числом или названием, например:
		cv::FILLED = -1
		cv::LINE_4 = 4
		cv::LINE_8 = 8
		cv::LINE_AA = 16
	7 - int shift - указывает, на сколько бит сдвинуть дробные части координат (x, y) и радиуса radius.
		Т.е. реальные координаты окружности = (переданные значения)/2^(shift).
		При shift = 0, координаты являются целыми числами.

	И другие... (см. Drawing Functions)
	*/
	cv::circle(img, cv::Point(128, 128), 64, cv::Scalar(255, 0, 0), 3);
	// cv::Rect(64, 128, 128, 128) - конструктор класса Rect. В параметрах первые два числа - (x, y),
	// следующие два числа - ширина и высота
	cv::rectangle(img, cv::Rect(64, 128, 64, 128), cv::Scalar(255, 0, 255), 3);

	imshow("Image", img);
	cv::waitKey(0);
}

/*
example4 - процедура, которая содержит прмер распознования лиц с веб-камеры
*/
void example4()
{
	/*
	VideoCapture videoCap - объект для захвата кадров из видео (из файла или веб-камеры).
	Его аргументом может быть либо индекс устройства, либо имя видеофайла.
	
	Индекс устройства — это номер, указывающий, какая камера. Обычно подключается одна камера (как в моем случае),
	поэтому я просто передаю 0 (или -1). Вы можете выбрать вторую камеру, передав 1 и т.д.
	*/
	cv::VideoCapture videoCap(0);

	/*
	CascadeClassifier facedetect - необходим для обнаружения объектов на изображениях с использованием каскадных
	классификаторов на основе признаков Хаара (Haar features) или локальных бинарных шаблонов (LBP).

	facedetect.load() - метод для загрузки файла с настройками для обнаружения. В данном случае загружается файл с
	настройкам для определения лиц на основе признаков Хаара.
	*/
	cv::CascadeClassifier facedetect;
	facedetect.load("E:/OpenCV_learn/Resources/haarcascade_frontalface_default.xml");

	cv::Mat img; // Переменная для хранения одного кадра

	while (true) // в бесконечном цикле начинаем обработку изображения с веб-камеры
	{
		videoCap.read(img); // считываем (захватываем) один кадр из изображения
		std::vector<cv::Rect> faces; // массив для хранения прямоугольников, которые показывает,
									 // где находятся лица в кадре

		/*
		detectMultiScale() - метод, который сканирует изображение в поисках объектов и
		возвращает их координаты в виде прямоугольников (std::vector<cv::Rect>).

		Параметры:
		1 - InputArray image - входное изображение (обязательно в градациях серого, CV_8U)
		2 - objects - выходной вектор с координатами (cv::Rect) обнаруженных объектов. В данной программе это faces.
		3 - double scaleFactor - насколько уменьшается изображение на каждом шаге (например, 1.1 = +10%).
			Чем больше, тем быстрее, но меньше точность.
		4 - int minNeighbors - фильтр ложных срабатываний. Чем выше, тем строже отбор (обычно 3-6).
		5 - int lags - устаревший параметр (в новых версиях OpenCV не используется), по умолчанию 0.
		6 - Size minSize - минимальный размер объекта (например, cv::Size(30, 30)).
		7 - Size maxSize - максимальный размер объекта (например, cv::Size(200, 200)).
		*/
		facedetect.detectMultiScale(img, faces, 1.3, 5);

		/*
		В цикле проходимся по всем лицам, которые нашел классификатор. И для каждого лица
		риусем прямоугольник в кадре, который покажет область, где было определено лицо.
		*/
		for (int i = 0; i < faces.size(); ++i)
		{
			// Прямоугольник для найденных лиц
			rectangle(img, faces[i].tl(),
					  faces[i].br(), cv::Scalar(50, 50, 255), 3);

			// Прямоугольник, который является фоном для текста сколько лиц найдено
			rectangle(img, cv::Point(0, 0), cv::Point(250, 70),
					  cv::Scalar(50, 50, 255), cv::FILLED);
			/*
			putText() - функция, которая отрисовывает текст в кадре.

			Параметры:
			1 - InputOutputArray img - изображение на котором будет отображаться окружность
			2 - String text - текст, который необходимо отрисовать
			3 - Point org - координаты откда начинать рисовать текст
			4 - int fontFace - тип шрифта
			5 - double fontScale - коэффициент масштабирования шрифта, умноженный на базовый размер шрифта
			6 - Scalar color - цвет шрифта (также задается в BGR)
			7 - int thickness - толщина линий шрифта
			8 - int lineType - тип линии. Задается числом или названием, например:
				cv::FILLED = -1
				cv::LINE_4 = 4
				cv::LINE_8 = 8
				cv::LINE_AA = 16
			9 - bool bottomLeftOrigin - если true, источник данных изображения находится в нижнем левом углу,
				иначе в верхнем левом углу.
			*/
			putText(img, std::to_string(faces.size()) + " Face Found",
					cv::Point(100, 40), cv::FONT_HERSHEY_DUPLEX, 1,
					cv::Scalar(255, 255, 255), 1);
		}


		imshow("Frame", img);
		cv::waitKey(1);
	}
}

int main(int argc, char* argv[])
{
	example4();
	
	return 0;
}